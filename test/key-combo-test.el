(require 'ert)
(require 'el-spec)
(require 'el-spy)

(require 'key-combo)
(key-combo-load-default)

(defun key-combo-test-helper-execute (cmd)
  (key-combo-mode 1)
  (execute-kbd-macro (key-combo-read-kbd-macro cmd))
  (substring-no-properties (buffer-string)))

(defun key-combo-test-helper-define-lookup (cmd)
  (key-combo-define-global ">>" cmd)
  (key-combo-key-binding ">>"))

(dont-compile
  (describe ("key-combo in temp-buffer")
    (shared-examples "check post-command-hook"
      (it ()
        (key-combo-mode 1)
        (should (memq 'key-combo-post-command-function
                      post-command-hook)))
      (it ()
        (key-combo-mode -1)
        (should-not (memq 'key-combo-post-command-function
                          post-command-hook))))
    (shared-examples "C-a"
      (before
        (insert "B\n IP")
        (key-combo-mode 1))
      (it ()
        (should (key-combo-key-binding (kbd "C-a C-a"))))
      ;; (it ()
      ;;   (key-combo-mode -1)
      ;;   (should-not (key-combo-key-binding (kbd "C-a C-a"))))
      (it ()
        (key-combo-test-helper-execute "C-a")
        (should (equal (char-to-string (following-char)) "I"))
        (should (eq real-last-command 'back-to-indentation))
        )
      (it ()
        (key-combo-test-helper-execute "C-a C-a")
        (should (equal (char-to-string (following-char)) " "))
        (should (eq real-last-command 'move-beginning-of-line))
        )
      (it ()
        (key-combo-test-helper-execute "C-a C-a C-a")
        (should (equal (char-to-string (following-char)) "B"))
        (should (eq real-last-command 'beginning-of-buffer))
        )
      (it ()
        (key-combo-test-helper-execute "C-a C-p"))
      ;; fail in temp buffer?
      ;; (it (:vars ((cmd "C-a C-a C-a C-a")))
      ;;   (backward-char)
      ;;   (should (equal (char-to-string (following-char)) "P")))
      )

    (around
      (with-temp-buffer
        (switch-to-buffer (current-buffer))
        (let ((global-map-org (current-global-map))
              (global-map (let ((map (make-sparse-keymap)))
                            (set-keymap-parent map (current-global-map)) map)))
          (unwind-protect
              (with-el-spy
               (use-global-map global-map)
               (funcall el-spec:example))
            (use-global-map global-map-org)))))

    (it "is key-combo element"
      (should (key-combo-elementp ">"))
      (should (key-combo-elementp '(lambda() (interactive) ())))
      (should (key-combo-elementp 'nil))
      (should (key-combo-elementp 'self-insert-command)))
    (it "is not key-combo element"
      (should-not (key-combo-elementp '(">")))
      (should-not (key-combo-elementp '((lambda() (interactive) ()))))
      (should-not (key-combo-elementp '(nil)))
      (should-not (key-combo-elementp '(self-insert-command)))
      (should-not (key-combo-elementp 'wrong-command)))
    (it "can define & lookup"
      (should (key-combo-test-helper-define-lookup '(lambda()(interactive)())))
      (should (key-combo-test-helper-define-lookup ">"))
      (should (key-combo-test-helper-define-lookup 'self-insert-command))
      (should (key-combo-test-helper-define-lookup '((lambda()(interactive)()))))
      (should (key-combo-test-helper-define-lookup '(">")))
      (should (key-combo-test-helper-define-lookup '(self-insert-command)))
      (should (key-combo-test-helper-define-lookup '(">" ">")))
      (should (key-combo-test-helper-define-lookup '(">" (lambda()(interactive)()))))
      (should (key-combo-test-helper-define-lookup '((lambda()(interactive)()) ">")))
      (should
       (key-combo-test-helper-define-lookup '((lambda()(interactive)()) (lambda()(interactive)()))))
      (should
       (key-combo-test-helper-define-lookup '(">" self-insert-command)))
      (should
       (key-combo-test-helper-define-lookup '(self-insert-command ">")))
      (should
       (key-combo-test-helper-define-lookup
        '(self-insert-command self-insert-command)))
      )
    ;;(include-examples "invalid examples name")
    (include-examples "check post-command-hook")
    (include-examples "C-a")
    (it "undo"
      ;; with-current-buffer (get-buffer-create "hoge")
      (erase-buffer)
      (buffer-disable-undo)
      (buffer-enable-undo)
      (insert "init:")
      (undo-boundary)
      (setq buffer-undo-list nil)

      (insert "1")
      (undo-boundary)
      (should (string= (buffer-string) "init:1"))

      (should (= (key-combo-count-boundary buffer-undo-list) 1))
      (primitive-undo 2 buffer-undo-list)
      (undo-boundary)
      (should (string= (buffer-string) "init:"))
      (setq buffer-undo-list (cdr buffer-undo-list))
      (insert "2")
      (undo-boundary)
      (should (string= (buffer-string) "init:2"))

      (should (= (key-combo-count-boundary buffer-undo-list) 2))
      (primitive-undo 3 buffer-undo-list)
      (undo-boundary)

      (should (string= (buffer-string) "init:"))
      (setq buffer-undo-list (cdr buffer-undo-list))
      (insert "3")
      (undo-boundary)
      (should (string= (buffer-string) "init:3"))
      (should (= (point) 7))

      (should (= (key-combo-count-boundary buffer-undo-list) 3))
      (primitive-undo 4 buffer-undo-list)
      (should (string= (buffer-string) "init:"))
      (insert "4")
      (undo-boundary)
      (should (string= (buffer-string) "init:4"))
      (should (= (point) 7))

      (undo)
      (should (string= (buffer-string) "init:3"))
      (should (= (point) 7))

      (undo-more 1)
      (should (string= (buffer-string) "init:2"))
      (should (= (point) 7))

      (undo-more 1)
      (should (string= (buffer-string) "init:1"))
      (should (= (point) 7))
      )

    (context "in default-mode"
      (context "with mock"
        (context "prefix"
          (before
            (buffer-enable-undo)
            (key-combo-mode 1)
            (defmock test1 () (interactive) (insert "test1"))
            (defmock test2 () (interactive) (insert "test2"))
            (defmock test3 () (interactive) (insert "test3"))
            ;; (funcall el-spec:example) ;raise error?
            )
          (it ()
            (define-prefix-command 'test-map)
            (global-set-key (kbd "M-s") 'test-map)
            (global-set-key (kbd "M-s z") 'test3)

            (should (string= (key-combo-test-helper-execute "M-s z")
                             "test3"))
            (should (eq (el-spy:called-count 'test1) 0))
            (should (eq (el-spy:called-count 'test2) 0))
            (should (eq (el-spy:called-count 'test3) 1))
            )
          (it ()
            (define-prefix-command 'test-map)
            (global-set-key (kbd "M-s") 'test-map)
            (global-set-key (kbd "M-s z") 'test3)

            (define-key global-map
              (key-combo-make-key-vector (kbd "M-s")) 'test1)
            (define-key global-map
              (key-combo-make-key-vector (kbd "M-s a")) 'test2)
            (should (string= (key-combo-test-helper-execute "M-s a")
                             "test2"))
            (should (eq (el-spy:called-count 'test1) 1))
            (should (eq (el-spy:called-count 'test2) 1))
            (should (eq (el-spy:called-count 'test3) 0))
            )
          (it ()
            (define-prefix-command 'test-map)
            (global-set-key (kbd "M-s") 'test-map)
            (define-key test-map (kbd "z")
              'test3)
            (define-key global-map
              (key-combo-make-key-vector (kbd "M-s"))
              'test1)
            (define-key global-map
              (key-combo-make-key-vector (kbd "M-s a"))
              'test2)
            (should (string= (key-combo-test-helper-execute "M-s")
                             "test1"))
            (should (eq (el-spy:called-count 'test1) 1))
            (should (eq (el-spy:called-count 'test2) 0))
            (should (eq (el-spy:called-count 'test3) 0))
            )
          (it ()
            (define-prefix-command 'test-map)
            (global-set-key (kbd "M-s") 'test-map)
            (define-key test-map (kbd "z")
              'test3)
            (define-key global-map
              (key-combo-make-key-vector (kbd "M-s"))
              'test1)
            (define-key global-map
              (key-combo-make-key-vector (kbd "M-s a"))
              'test2)
            (should (string= (key-combo-test-helper-execute "M-s z")
                             "test3"))
            (should (eq (el-spy:called-count 'test1) 1))
            (should (eq (el-spy:called-count 'test2) 0))
            (should (eq (el-spy:called-count 'test3) 1))
            )
          (it ()
            (define-prefix-command 'test-map)
            (global-set-key (kbd "M-s") 'test-map)
            (define-key test-map (kbd "z")
              'test3)
            (key-combo-define-global (kbd "M-s") 'test1)
            (key-combo-define-global (kbd "M-s a") 'test2)
            (should (string= (key-combo-test-helper-execute "M-s a")
                             "test2"))
            (should (eq (el-spy:called-count 'test1) 1))
            (should (eq (el-spy:called-count 'test2) 1))
            (should (eq (el-spy:called-count 'test3) 0))
            )
          (it ("multiple prefix")
            ;; "a M-s"
            )
          (it ("multiple prefix2")
            ;; "M-s M-s"
            )
          (it ("define key")
            ;; "M-s M-s"
            )
          )
        (it ()
          (should-error
           (with-mock
             (mock (test1 *) :times 1)
             (key-combo-define-global (kbd "M-C-d") '(test1 test2)))))
        (it ()
          ;; no error
          (with-el-spy
           (defmock test1 () (interactive))
           (defmock test2 () (interactive))
           (key-combo-mode 1)
           (key-combo-define-global (kbd "M-C-d") 'test1)
           (execute-kbd-macro (kbd "M-C-d"))
           ;; (should (eq (el-spy:called-count 'test1) 1))
           ))
        (it ()
          ;; no error
          (with-el-spy
           (defmock test1 () (interactive))
           (defmock test2 () (interactive))
           (key-combo-mode 1)
           (key-combo-define-global (kbd "M-C-d") '(test1 test2))
           (execute-kbd-macro (kbd "M-C-d"))
           ;; (should (eq (el-spy:called-count 'test1) 1))
           ))
        (it ()
          ;; no error
          (with-el-spy
           (defmock test1 () (interactive))
           (defmock test2 () (interactive))
           (key-combo-mode 1)
           (key-combo-define-global (kbd "M-C-d") '(test1 test2))
           (execute-kbd-macro (kbd "M-C-d M-C-d"))
           (should (eq (el-spy:called-count 'test1) 1))
           (should (eq (el-spy:called-count 'test2) 1))
           ))
        (it ()
          ;; no error
          (with-el-spy
           (defmock define-key (keymap key def) 0)
           (use-local-map (make-sparse-keymap))
           (key-combo-define-local "a" "a")
           (should (eq (el-spy:called-count 'define-key) 1))))
        (it ()
          ;; no error
          (with-el-spy
           (defmock define-key (keymap key def) 0)
           ;; (mock (define-key * * *) :times 1)
           (use-local-map (make-sparse-keymap))
           (key-combo-define-local "a" '("a"))
           (should (eq (el-spy:called-count 'define-key) 1))))
        (it ()
          ;; no error
          (with-el-spy
           (defmock define-key (keymap key def) 0)
           (use-local-map (make-sparse-keymap))
           ;; (mock (define-key * * *) :times 3);; 1 for recursive call?
           (key-combo-define-local "a" '("a" "b"))
           (should (eq (el-spy:called-count 'define-key) 2))))
        (it ()
          ;; no error
          (with-el-spy
           (defmock define-key (keymap key def) 0)
           (defmock lookup-key (keymap key) t)
           (use-local-map (make-sparse-keymap))
           ;; (mock (lookup-key * *) => t :times 2)
           ;; (mock (define-key * * *) :times 2);; 1 for recursive call?
           (key-combo-define-local "a" '("a" "b"))
           (should (eq (el-spy:called-count 'define-key) 2))
           (should (eq (el-spy:called-count 'lookup-key) 4))
           ))
        )
      (context "execute"
        (it ()
          (should (string= (key-combo-test-helper-execute ">") ">")))
        (it ()
          (should (string= (key-combo-test-helper-execute "=") "="))))
      (context "no execute"
        ;; (it ()
        ;;   (key-combo-command-execute (lambda () (insert "a")))
        ;;   (should (string= (buffer-string) "a")))
        ;; (it ()
        ;;   (should-error (key-combo-command-execute 'wrong-command)))
        ;; (it ()
        ;;   (let ((last-command-event ?b))
        ;;     (key-combo-command-execute 'self-insert-command))
        ;;   (should (string= (buffer-string) "b")))
        ;; (it ()
        ;;   (key-combo-command-execute (key-combo-get-command "a"))
        ;;   (should (string= (buffer-string) "a")))
        ;; (it ()
        ;;   (key-combo-command-execute (key-combo-get-command "a`!!'a"))
        ;;   (should (string= (buffer-string) "aa"))
        ;;   (should (eq (point) 2)))
        ;; (it ()
        ;;   (buffer-enable-undo)
        ;;   (let ((key-combo-undo-list))
        ;;     (key-combo-command-execute (lambda() (insert "a")))
        ;;     (key-combo-undo))
        ;;   (should (string= (buffer-string) "")))
        ;; (it ()
        ;;   (buffer-enable-undo)
        ;;   (let ((key-combo-undo-list))
        ;;     (key-combo-command-execute (key-combo-get-command "a`!!'a"))
        ;;     (key-combo-undo))
        ;;   (should (string= (buffer-string) "")))
        (it ()
          (should-error (key-combo-define-global "a" 'wrong-command)))
        (it ()
          (should (key-combo-define-global "a" 'self-insert-command)))
        (it ()
          (should (eq (key-combo-define-global "a" nil) nil)))
        (it ()
          (should (eq (key-combo-define-global (kbd "C-M-g") nil) nil)))))
    (context "in emacs-lisp-mode"
      (before
        (buffer-enable-undo)
        (emacs-lisp-mode))
      (it ()
        (key-combo-define-global (kbd "M-s") "a"))
      (it ()
        (should-not (key-combo-comment-or-stringp)))
      (it ()
        (insert "\"")
        (should (key-combo-comment-or-stringp)))
      (it ()
        (insert ";")
        (should (key-combo-comment-or-stringp)))
      (it ()
        (insert ";\n")
        (should-not (key-combo-comment-or-stringp)))
      (context "isearch-mode"
        (it ()
          (insert "=")
          (should (string= (buffer-string) "="))
          (should (eq (point) 2)))
        (it ()
          (insert "=");; not to raise error from isearch-search
          (isearch-mode nil);; backward search
          (execute-kbd-macro "=")
          (should (string= (buffer-string) "="))
          (should (eq (point) 1))))
      (context "execute only"
        (it ()
          (should (string= (key-combo-test-helper-execute "=") "= ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "= =") "eq ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "=") "= "))
          (undo -1)
          (should (string= (buffer-string) "="))
          )
        (it ()
          (insert "init:")
          (should (string= (key-combo-test-helper-execute "=") "init:= "))
          (undo -1)
          (should (string= (buffer-string) "init:="))
          (undo-more 1)
          (should (string= (buffer-string) ""))
          )
        (it ()
          (buffer-enable-undo)
          (should (null buffer-undo-list))
          (should (string= (key-combo-test-helper-execute "= =") "eq "))
          ;; (primitive-undo 1 buffer-undo-list)
          (undo -1)
          (should (string= (buffer-string) "= "))
          )
        (it ()
          (should (string= (key-combo-test-helper-execute ",") ",")))
        (it ()
          (should (string= (key-combo-test-helper-execute ",,") ",,")))
        (it ()
          (should (string= (key-combo-test-helper-execute ".") ".")))
        (it ()
          (should (string= (key-combo-test-helper-execute ". SPC") " . ")))
        (it ()
          (should (string= (key-combo-test-helper-execute ";") ";; ")))
        (it ()
          (should (string= (key-combo-test-helper-execute ";.") ";; .")))
        (it ()
          (should (string= (key-combo-test-helper-execute ";,") ";; ,")))
        (it ()
          (insert ";")
          (should (string= (key-combo-test-helper-execute "=") ";=")))
        )
      (context "in skk-mode"
        (when (require 'skk-autoloads nil t)
          (before
            (skk-mode 1)
            (setq this-command 'skk-insert)
            (insert ";")
            )
          (it ()
            (should (string= (key-combo-test-helper-execute ",") ";、")))
          (it ()
            (should (string= (key-combo-test-helper-execute ".") ";。")))
          )
        )
      (context ("insert & move & execute" :vars (pos pre-string))
        (it ()
          (insert "\"")
          (should (string= (key-combo-test-helper-execute "=") "\"=")))
        (it ()
          (insert ";")
          (should (string= (key-combo-test-helper-execute "=") ";=")))
        (it ()
          (insert ";")
          (should (string= (key-combo-test-helper-execute ",") ";,")))
        (it ()
          (insert ";\n")
          (should (string= (key-combo-test-helper-execute ";") ";\n;; ")))
        (it ()
          (insert ";")
          (should (string= (key-combo-test-helper-execute ".") ";.")))
        (it ()
          (insert "\"\"\n")
          (goto-char 3)
          (should (string= (key-combo-test-helper-execute ".") "\"\".\n")))
        (it ()
          (insert "\"\"a")
          (goto-char 3)
          (should (string= (key-combo-test-helper-execute ".") "\"\".a")))
        (it ()
          (insert "\"\"")
          (goto-char 3)
          (should (string= (key-combo-test-helper-execute ".") "\"\".")))
        (it ()
          (insert "\"\"")
          (goto-char 2)
          (should (string= (key-combo-test-helper-execute ".") "\".\"")))
        (it ()
          (insert "a\"\"")
          (goto-char 2)
          (should (string= (key-combo-test-helper-execute ".") "a.\"\"")))
        )
      (include-examples "C-a")
      (include-examples "check post-command-hook"))
    (context "in ruby"
      (before
        (buffer-enable-undo)
        (key-combo-mode 1)
        (ruby-mode)
        (when (boundp 'auto-complete-mode)
          (auto-complete-mode -1)))
      ;; bug?for auto-complete completion
      (it ()
        (should (string= (key-combo-test-helper-execute ".") ".")))
      (it ()
        (should (string= (key-combo-test-helper-execute "..") "..")))
      (it ()
        (should (string= (key-combo-test-helper-execute "...") "...")))
      (it ()
        (should (string= (key-combo-test-helper-execute "!~") " !~ ")))
      (it ()
        (should (string= (key-combo-test-helper-execute "**") "**")))
      (it ()
        (should (string= (key-combo-test-helper-execute "||=") " ||= "))))
    (context "in c-mode"
      (before
        (buffer-enable-undo)
        ;; (key-combo-mode 1)
        (c-mode))
      (context "execute+"
        (it ()
          (should (string= (key-combo-test-helper-execute "+") " + ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "++") "++")))
        ;; (it ()
        ;;   (should (string= (key-description "+") "+")))
        (it ()
          (should (equal (listify-key-sequence "+") '(43))))
        (it ()
          (should (string= (key-description '(?+)) "+")))
        (it ()
          (should (equal (key-combo-make-key-vector '(?+))
                         ;;(vector 'key-combo (intern (key-description )))
                         [key-combo _+])))
        (it ("a")
          (should (not (null (key-binding
                              (key-combo-make-key-vector '(?+))
                              )))))
        (it ("c")
          (should (not (null (lookup-key
                              (current-local-map)
                              (key-combo-make-key-vector '(?+))
                              )))))
        (it ("b")
          (should (not (equal (key-binding
                               (key-combo-make-key-vector '(?+)))
                              'key-combo-execute-original))))
        (it ()
          (should (not (null (key-combo-get-command "+")))))
        (it ()
          (should (not (equal (key-combo-get-command "+")
                              'key-combo-execute-original))))
        (it ("d")
          (key-combo-define-local "a" nil)
          ;; (key-combo-key-binding "a")
          ;; (key-binding (vector 'key-combo (intern (key-description "a"))))
          ;; accept-default bug?
          (should (eq (lookup-key (current-local-map)
                                  (key-combo-make-key-vector '(?a)))
                      nil))
          (key-combo-define-local "a" "a")
          (should (not (equal (lookup-key (current-local-map)
                                          (key-combo-make-key-vector '(?a)))
                              nil)))
          (key-combo-define-local "a" nil)
          )
        )
      (context "undo"
        (before
          (buffer-enable-undo))
        (it ()
          (should (string= (key-combo-test-helper-execute "=") " = ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "=") " = "))
          (undo -1)
          (should (string= (buffer-string) "="))
          )
        (it ()
          (should (string= (key-combo-test-helper-execute "= C-x u") "=")))
        (it ()
          (should (string= (key-combo-test-helper-execute "== C-x u") " = ")))
        )
      (context "execute"
        (it ()
          (should (string= (key-combo-test-helper-execute "=") " = ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "=*") " =* ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "==") " == ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "===") " === ")))
        (it "loop"
          (should (string= (key-combo-test-helper-execute "====") " = ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "=>=") " => = ")))
        ;; (it ()
        ;; (should (string= (key-combo-test-helper-execute "==!") " ==! ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "=>") " => ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "/") "/")))
        (it ()
          (should (string= (key-combo-test-helper-execute "/ SPC") " / ")))
        (it ()
          (should (string= (key-combo-test-helper-execute "*") "*")))
        (it ()
          (should (string= (key-combo-test-helper-execute "**") "**")))
        (it ()
          (should (string= (key-combo-test-helper-execute "->") "->")))
        (it ()
          (should (string= (key-combo-test-helper-execute ".") ".")))
        ;; todo check position
        (it ()
          (should (string= (key-combo-test-helper-execute "/* RET")
                           "/*\n  \n */")))
        ;; todo depend on indent width
        ;; (it ()
        ;; (should (string= (key-combo-test-helper-execute "{ RET") "{\n  \n}"))
        )
      (context "funcall"
        ;; (before
        ;;   (key-combo-command-execute (key-combo-key-binding lookup-cmd)))
        (it ()
          (should (string=
                   (key-combo-test-helper-execute "=") " = ")))
        (it ()
          (should (string=
                   (key-combo-test-helper-execute "==") " == ")))
        (it ()
          (should (string=
                   (key-combo-test-helper-execute "=>") " => ")))
        (it ()
          (should (string=
                   (key-combo-test-helper-execute "===")
                   " === ")))
        ;; (it ()
        ;;   (funcall (key-combo-key-binding [?= ?= ?= ?=]))
        ;;   (should (string= (buffer-string) " ==== ")))
        ;; (it ()
        ;;   (key-combo-define-global (kbd "C-M-h") " == ")
        ;;   (key-combo-command-execute (key-combo-key-binding (kbd "C-M-h")))
        ;;   (should (equal (buffer-string) " == ")))
        (it ()
          (should-not
           (equal
            (key-combo-lookup-key (current-global-map) (kbd "C-M-h"))
            " == ")))
        ;; (it ()
        ;;   (key-combo-define-global (kbd "C-M-h C-M-h") " === ")
        ;;   (execute-kbd-macro (kbd "C-M-h C-M-h"))
        ;;   (should (string= (buffer-string) " === "))
        ;;   )
        ;; (it ()
        ;;   (key-combo-define-global (kbd "C-M-h C-M-h") " === ")
        ;;   (key-combo-command-execute
        ;;    (key-combo-key-binding (kbd "C-M-h C-M-h")))
        ;;   (should (string= (buffer-string) " === "))
        ;;   )
        (it ()
          (should-not (key-combo-key-binding [?= ?= ?= ?=])))
        (it ()
          (insert "a  ")
          (should (string= (key-combo-test-helper-execute "=") "a  = "))
          (should (string= (buffer-string) "a  = ")))
        )
      )
    ))
;; todo:test for eldoc
